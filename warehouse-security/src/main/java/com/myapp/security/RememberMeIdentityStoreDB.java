package com.myapp.security;

import javax.ejb.EJB;
import javax.ejb.Local;
import javax.enterprise.context.ApplicationScoped;
import javax.security.enterprise.CallerPrincipal;
import javax.security.enterprise.credential.RememberMeCredential;
import javax.security.enterprise.identitystore.CredentialValidationResult;
import javax.security.enterprise.identitystore.RememberMeIdentityStore;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.HashSet;
import java.util.Optional;
import java.util.Set;

import static javax.security.enterprise.identitystore.CredentialValidationResult.INVALID_RESULT;

/**
 * <p>Created by MontolioV on 13.03.18.
 */

@ApplicationScoped
@Local(RememberMeIdentityStore.class)
public class RememberMeIdentityStoreDB implements RememberMeIdentityStore {
    @EJB
    private AccountStore accountStoreDB;
    @EJB
    private TokenStore tokenStore;

    /**
     * Validates the given credential.
     *
     * @param credential The credential to validate.
     * @return The validation result, including associated caller groups.
     */
    @Override
    public CredentialValidationResult validate(RememberMeCredential credential) {
        Optional<Account> optional = accountStoreDB.getAccountByTokenHash(credential.getToken());
        if (optional.isPresent()) {
            Account account = optional.get();
            Set<String> rolesStrSet = new HashSet<>();
            account.getRoles().forEach(roles -> rolesStrSet.add(roles.name()));
            return new CredentialValidationResult(account.getLogin(), rolesStrSet);
        } else {
            return INVALID_RESULT;
        }
    }

    /**
     * Associates the given principal and groups with a token.
     * <p>
     * The token generated by this method is intended to be used with the
     * {@link RememberMeCredential} and passed into the {@link #validate(RememberMeCredential)}
     * method.
     *
     * @param callerPrincipal The principal to be associated.
     * @param groups          The groups the principal is in.
     * @return A token that can be used to get the principal and groups back at a later time.
     */
    @Override
    public String generateLoginToken(CallerPrincipal callerPrincipal, Set<String> groups) {
        Optional<Account> optional = accountStoreDB.getAccountByLogin(callerPrincipal.getName());
        if (optional.isPresent()) {
            Date expiring = Date.from(Instant.now().plus(14, ChronoUnit.DAYS));
            return tokenStore.createToken(optional.get(), TokenType.REMEMBER_ME, expiring)
                             .getTokenHash();
        } else {
            return null;
        }
    }

    /**
     * Dissociates the principal and groups that were associated with the token before
     * and removes the token itself.
     * <p>
     * If the token did not exist (i.e. no principal and groups were associated with that token)
     * no exception will be thrown.
     *
     * @param tokenStr The token that is to be removed.
     */
    @Override
    public void removeLoginToken(String tokenStr) {
        tokenStore.removeToken(tokenStr);
    }
}
